import{_ as s,o as a,c as l,V as n}from"./chunks/framework.3aae2b97.js";const m=JSON.parse('{"title":"1. 浏览器渲染流程","description":"","frontmatter":{},"headers":[],"relativePath":"column/5.browser/01. 浏览器的渲染流程/浏览器渲染流程.md","filePath":"column/5.browser/01. 浏览器的渲染流程/浏览器渲染流程.md","lastUpdated":1690463223000}'),p={name:"column/5.browser/01. 浏览器的渲染流程/浏览器渲染流程.md"},o=n(`<h1 id="_1-浏览器渲染流程" tabindex="-1">1. 浏览器渲染流程 <a class="header-anchor" href="#_1-浏览器渲染流程" aria-label="Permalink to &quot;1. 浏览器渲染流程&quot;">​</a></h1><p>本文主要包含以下内容：</p><ul><li>浏览器渲染整体流程</li><li><em>DOM</em> 树的形成</li><li><em>CSSOM</em> 树的形成</li><li>生成渲染树</li><li>阻塞渲染</li><li>重绘和回流 <ul><li>现代浏览器的优化机制</li><li>减少回流和重绘的方式</li></ul></li><li>一道常见的面试题</li></ul><h2 id="浏览器渲染整体流程" tabindex="-1">浏览器渲染整体流程 <a class="header-anchor" href="#浏览器渲染整体流程" aria-label="Permalink to &quot;浏览器渲染整体流程&quot;">​</a></h2><p>整个页面可以看做是一幅画，这幅画是由浏览器绘制出来的，浏览器绘制这幅画的过程称之为渲染。</p><p>渲染是一件复杂的工作，它大致分为以下几个过程：</p><ol><li>解析 <em>HTML</em>，生成 <em>DOM</em> 树，解析 <em>CSS</em>，生成样式规则树</li><li>将 <em>DOM</em> 树和样式规则树结合，生成渲染树（ <em>Render Tree</em> ）</li><li>根据生成的渲染树，确定元素的布局信息（元素的尺寸、位置），<strong>这一步称之为 <em>reflow</em>，译作回流或重排</strong></li><li>根据渲染树和布局信息，生成元素的像素信息（元素横纵的像素点，左上角的偏移量、每个像素的颜色等）。<strong>这一步称之为 <em>repaint</em>，译作重绘</strong></li><li>将像素信息提交到 <em>GPU</em> 完成屏幕绘制</li></ol><p>当元素的布局信息发生变化时，会导致回流。当元素的像素信息发生变化时，会导致重绘。回流一定会导致重绘，因为布局信息的变化一定会导致像素信息的变化。</p><p>在实际开发中，获取和设置元素尺寸、位置均会导致回流和重绘，而仅设置元素的外观（比如背景颜色）则只会导致重绘，不会导致回流。</p><p>回流是一项繁琐的工作，会降低效率，因此在开发中，应该尽量避免直接获取和设置元素的尺寸、位置，尽量使用变量来保存元素的布局信息。</p><p>下面，我们将具体来看一下浏览器在渲染页面时每一个步骤。</p><h2 id="dom-树的形成" tabindex="-1"><em>DOM</em> 树的形成 <a class="header-anchor" href="#dom-树的形成" aria-label="Permalink to &quot;*DOM* 树的形成&quot;">​</a></h2><p>当我们打开一个网页时，浏览器都会去请求对应的 <em>HTML</em> 文件。虽然平时我们写代码时都会分为 <em>HTML、CSS、JS</em> 文件，也就是字符串，但是计算机硬件是不理解这些字符串的，所以在网络中传输的内容其实都是 <em>0</em> 和 <em>1</em> 这些字节数据。</p><p>当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-11-20-091349.png" alt="image-20211120171348433" style="zoom:50%;"><p>当数据转换为字符串以后，浏览器会先将这些字符串通过词法分析转换为标记（ <em>token</em> ），这一过程在词法分析中叫做标记化（ <em>tokenization</em> ）。</p><p>那么什么是标记呢？</p><p>这其实属于编译原理这一块的内容了。简单来说，标记还是字符串，是构成代码的最小单位。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思。</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-11-20-091409.png" alt="image-20211120171408897" style="zoom:50%;"><p>当结束标记化后，这些标记会紧接着转换为 <em>DOM</em> 节点，之后所有的 <em>DOM</em> 节点会根据彼此之间的关系形成一颗 <em>DOM</em> 节点树。</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-11-20-091428.png" alt="image-20211120171428854" style="zoom:50%;"><p>以上就是浏览器从网络中接收到 <em>HTML</em> 文件然后一系列的转换过程。</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-11-20-091451.png" alt="image-20211120171451336" style="zoom:50%;"><h2 id="cssom-树的形成" tabindex="-1"><em>CSSOM</em> 树的形成 <a class="header-anchor" href="#cssom-树的形成" aria-label="Permalink to &quot;*CSSOM* 树的形成&quot;">​</a></h2><p>接下来是转换 <em>CSS</em> 到 <em>CSSOM</em> 树的过程。整体流程和上面类似：</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-11-20-091510.png" alt="image-20211120171510677" style="zoom:50%;"><p>在这一过程中，浏览器会确定每一个节点的样式到底是什么，并最终生成一颗样式规则树，这棵树上面记录了每一个 <em>DOM</em> 节点的样式。</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-11-20-091530.png" alt="image-20211120171529844" style="zoom:50%;"><p>将 <em>CSS</em> 从字节数据转换为 <em>CSSOM</em> 这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器需要递归 <em>CSSOM</em> 树，然后确定具体的元素到底是什么样式。</p><p>举个例子：</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">a</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">href</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">#</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">span</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">span</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><div class="language-css"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">span</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#B2CCD6;">color</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> red</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFCB6B;">div</span><span style="color:#89DDFF;">&gt;</span><span style="color:#FFCB6B;">a</span><span style="color:#89DDFF;">&gt;</span><span style="color:#FFCB6B;">span</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#B2CCD6;">color</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> red</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 <em>span</em> 标签然后设置颜色。</p><p>但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 <em>span</em> 标签，然后找到 <em>span</em> 标签上的 <em>a</em> 标签，最后再去找到 <em>div</em> 标签，然后给符合这种条件的 <em>span</em> 标签设置颜色，这样的递归过程就很复杂。</p><p>所以我们应该尽可能的避免写过于具体的 <em>CSS</em> 选择器，然后对于 <em>HTML</em> 来说也尽量少的添加无意义标签，保证层级扁平。</p><h2 id="生成渲染树" tabindex="-1">生成渲染树 <a class="header-anchor" href="#生成渲染树" aria-label="Permalink to &quot;生成渲染树&quot;">​</a></h2><p>当我们生成 <em>DOM</em> 树和 <em>CSSOM</em> 树以后，就需要将这两棵树组合为渲染树（ <em>Render Tree</em> ）。</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-11-20-091551.png" alt="image-20211120171550663" style="zoom:50%;"><p>在这一过程中，不是简单的将两者合并就行了。渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是 <em>display: none</em> 的，那么就不会在渲染树中显示。</p><p>当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流），之后确定每一个像素点的信息（重绘），然后调用 <em>GPU</em> 绘制，合成图层，显示在屏幕上。对于这一部分的内容因为过于底层，还涉及到了硬件相关知识，这里就不再继续展开内容了。</p><h2 id="阻塞渲染" tabindex="-1">阻塞渲染 <a class="header-anchor" href="#阻塞渲染" aria-label="Permalink to &quot;阻塞渲染&quot;">​</a></h2><p>首先渲染的前提是已经生成了渲染树（ <em>Render Tree</em> ）。而生成渲染树的前提是生成了 <em>DOM</em> 树和 <em>CSSOM</em> 样式规则树。</p><p>所以如果想要渲染的速度加快，我们就应该降低要渲染的文件的大小，并且 <em>HTML</em> 节点的层级扁平化（没有无意义的标签），优化选择器。</p><p>当浏览器在解析到 <em>script</em> 标签时，会暂停构建 <em>DOM</em>，原因很简单，因为 <em>JS</em> 能够修改 <em>DOM</em> 节点，所以浏览器会先执行 <em>JS</em> 代码，当 <em>JS</em> 代码执行完成后才会从暂停的地方重新开始。</p><p>也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 <em>JS</em> 文件，这也是都建议将 <em>script</em> 标签放在 <em>body</em> 标签底部的原因。</p><p>另外，在现代浏览器中，为我们提供了新的方式来避免 <em>JS</em> 代码阻塞渲染的情况：</p><ul><li><em>async</em></li><li><em>defer</em></li><li><em>prefetch</em></li><li><em>preload</em></li></ul><p>关于这几种方式的区别，我们在另外一篇文章中再具体来看。</p><h2 id="重绘和回流" tabindex="-1">重绘和回流 <a class="header-anchor" href="#重绘和回流" aria-label="Permalink to &quot;重绘和回流&quot;">​</a></h2><p>重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。</p><ul><li>重绘：当节点需要更改外观而不会影响布局的，比如改变 <em>color</em> 就叫称为重绘</li><li>回流：布局或者几何属性需要改变就称为回流。</li></ul><p>**回流必定会发生重绘，重绘不一定会引发回流。**因此回流所需的成本比重绘高得多，改变父节点里的子节点很可能会导致父节点的一系列回流。</p><p>当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：</p><ul><li><p>添加或删除可见的 <em>DOM</em> 元素</p></li><li><p>元素的位置发生变化</p></li><li><p>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</p></li><li><p>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</p></li><li><p>页面一开始渲染的时候（这肯定避免不了）</p></li><li><p>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</p></li></ul><h3 id="现代浏览器的优化机制" tabindex="-1">现代浏览器的优化机制 <a class="header-anchor" href="#现代浏览器的优化机制" aria-label="Permalink to &quot;现代浏览器的优化机制&quot;">​</a></h3><p>现代的浏览器都是很聪明的，由于每次重排（回流）都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。</p><p>浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。</p><p>但是，当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法：</p><ul><li><p><em>offsetTop、offsetLeft、offsetWidth、offsetHeight</em></p></li><li><p><em>scrollTop、scrollLeft、scrollWidth、scrollHeight</em></p></li><li><p><em>clientTop、clientLeft、clientWidth、clientHeight</em></p></li><li><p><em>getComputedStyle( )</em></p></li><li><p><em>getBoundingClientRect</em></p></li></ul><p>更多会触发回流的属性和方法可以参阅：<em><a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a" target="_blank" rel="noreferrer">https://gist.github.com/paulirish/5d52fb081b3570c81e3a</a></em></p><h3 id="减少回流和重绘的方式" tabindex="-1">减少回流和重绘的方式 <a class="header-anchor" href="#减少回流和重绘的方式" aria-label="Permalink to &quot;减少回流和重绘的方式&quot;">​</a></h3><p>接下来，让我们谈谈如何减少回流和重绘。</p><h4 id="_1-最小化重绘和回流" tabindex="-1">1. 最小化重绘和回流 <a class="header-anchor" href="#_1-最小化重绘和回流" aria-label="Permalink to &quot;1. 最小化重绘和回流&quot;">​</a></h4><p>由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对 <em>DOM</em> 和样式的修改，然后一次处理掉。考虑这个例子：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> el </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">test</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">el</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">style</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">padding </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">5px</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">el</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">style</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">borderLeft </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">1px</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">el</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">style</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">borderRight </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">2px</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>例子中，有三个样式属性被修改了，每一个都会影响元素的几何结构，引起回流。</p><p>当然，大部分现代浏览器都对其做了优化，因此，只会触发一次重排。但是如果在旧版的浏览器或者在上面代码执行的时候，有其他代码访问了布局信息(上文中的会触发回流的布局信息)，那么就会导致三次重排。</p><p>因此，我们可以合并所有的改变然后依次处理，比如我们可以采取以下的方式。</p><p>使用 <em>cssText</em></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> el </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">test</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">el</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">style</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">cssText </span><span style="color:#89DDFF;">+=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">border-left: 1px; border-right: 2px; padding: 5px;</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>将要修改的 <em>CSS</em> 样式写在一个样式类里面，然后通过添加和删除该样式类的方式来改变样式</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> el </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">test</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">el</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">className </span><span style="color:#89DDFF;">+=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;"> active</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span></code></pre></div><h4 id="_2-批量修改-dom" tabindex="-1">2. 批量修改 <em>DOM</em> <a class="header-anchor" href="#_2-批量修改-dom" aria-label="Permalink to &quot;2. 批量修改 *DOM*&quot;">​</a></h4><p>当我们需要对 <em>DOM</em> 对一系列修改的时候，可以通过以下步骤减少回流重绘次数：</p><ol><li><p>使元素脱离文档流</p></li><li><p>对其进行多次修改</p></li><li><p>将元素带回到文档中。</p></li></ol><p>该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对 <em>DOM</em> 的所有修改都不会引起回流，因为它已经不在渲染树了。</p><p>有三种方式可以让 <em>DOM</em> 脱离文档流：</p><ul><li><p>隐藏元素，应用修改，重新显示</p></li><li><p>使用文档片段（ <em>document fragment</em> ）在当前 <em>DOM</em> 之外构建一个子树，再把它拷贝回文档。</p></li><li><p>将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</p></li></ul><p>考虑我们要执行一段批量插入节点的代码：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">appendDataToElement</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">appendToElement</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">data</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">li</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">i</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">i</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">data</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">length</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">i</span><span style="color:#89DDFF;">++</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">li</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">createElement</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">li</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">li</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">textContent</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">text</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">appendToElement</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">appendChild</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">li</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> ul </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">list</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">appendDataToElement</span><span style="color:#A6ACCD;">(ul</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> data)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>如果我们直接这样执行的话，由于每次循环都会插入一个新的节点，会导致浏览器回流一次。</p><p>我们可以使用上面所提到的三种方式进行优化。</p><p>（1）隐藏元素，应用修改，重新显示</p><p>这个会在展示和隐藏节点的时候，产生两次重绘。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">appendDataToElement</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">appendToElement</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">data</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">li</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">i</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">i</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">data</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">length</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">i</span><span style="color:#89DDFF;">++</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">li</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">createElement</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">li</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">li</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">textContent</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">text</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">appendToElement</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">appendChild</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">li</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> ul </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">list</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">ul</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">style</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">display </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">none</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">appendDataToElement</span><span style="color:#A6ACCD;">(ul</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> data)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">ul</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">style</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">display </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">block</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>（2）使用文档片段（ <em>document fragment</em> ）在当前 <em>DOM</em> 之外构建一个子树，再把它拷贝回文档</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> ul </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">list</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> fragment </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">createDocumentFragment</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">appendDataToElement</span><span style="color:#A6ACCD;">(fragment</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> data)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">ul</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">appendChild</span><span style="color:#A6ACCD;">(fragment)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>（3）将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> ul </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">list</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> clone </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ul</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">cloneNode</span><span style="color:#A6ACCD;">(</span><span style="color:#FF9CAC;">true</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">appendDataToElement</span><span style="color:#A6ACCD;">(clone</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> data)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">ul</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">parentNode</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">replaceChild</span><span style="color:#A6ACCD;">(clone</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> ul)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><h4 id="_3-避免触发同步布局事件" tabindex="-1">3. 避免触发同步布局事件 <a class="header-anchor" href="#_3-避免触发同步布局事件" aria-label="Permalink to &quot;3. 避免触发同步布局事件&quot;">​</a></h4><p>上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。</p><p>举个例子，比如说我们想将一个 <em>p</em> 标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">initP</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">i</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">i</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">paragraphs</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">length</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">i</span><span style="color:#89DDFF;">++</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">paragraphs</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">i</span><span style="color:#F07178;">]</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">style</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">width</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">box</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">offsetWidth</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">px</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>这段代码看上去是没有什么问题，可是其实会造成很大的性能问题。</p><p>在每次循环的时候，都读取了 <em>box</em> 的一个 <em>offsetWidth</em> 属性值，然后利用它来更新 <em>p</em> 标签的 <em>width</em> 属性。</p><p>这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。每一次循环都会强制浏览器刷新队列，一刷新队列就会引发回流和重绘。</p><p>我们可以优化为：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> width </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> box</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">offsetWidth</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">initP</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">i</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">i</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">paragraphs</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">length</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">i</span><span style="color:#89DDFF;">++</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">paragraphs</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">i</span><span style="color:#F07178;">]</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">style</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">width</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">width</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">px</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h4 id="_4-复杂动画脱离文档流" tabindex="-1">4. 复杂动画脱离文档流 <a class="header-anchor" href="#_4-复杂动画脱离文档流" aria-label="Permalink to &quot;4. 复杂动画脱离文档流&quot;">​</a></h4><p>对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。</p><h4 id="_5-css3-硬件加速-gpu-加速" tabindex="-1">5. <em>CSS3</em> 硬件加速（ <em>GPU</em> 加速 ） <a class="header-anchor" href="#_5-css3-硬件加速-gpu-加速" aria-label="Permalink to &quot;5. *CSS3* 硬件加速（ *GPU* 加速 ）&quot;">​</a></h4><p>比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。</p><p>使用 <em>CSS3</em> 硬件加速，可以让 <em>transform、opacity、filters</em> 这些动画不会引起回流重绘。但是对于动画的其它属性，比如 <em>background-color</em> 这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</p><p>常见的触发硬件加速的 <em>CSS</em> 属性：</p><ul><li><p><em>transform</em></p></li><li><p><em>opacity</em></p></li><li><p><em>filters</em></p></li><li><p><em>Will-change</em></p></li></ul><h2 id="一道常见的面试题" tabindex="-1">一道常见的面试题 <a class="header-anchor" href="#一道常见的面试题" aria-label="Permalink to &quot;一道常见的面试题&quot;">​</a></h2><p>至此，你明白了浏览器渲染一张页面的整体流程，每一个步骤是在做什么事情，也知道了经常听到别人口中的回流和重绘是什么意思，并且知道一些能够避免回流和重绘的方法。</p><p>最后，我们以一道经常被问到的面试题结束本篇文章。</p><p><strong>经典真题：为什么操作 <em>DOM</em> 慢？</strong></p><p>参考答案：因为 <em>DOM</em> 是属于渲染引擎中的东西，而 <em>JS</em> 又是 <em>JS</em> 引擎中的东西。当我们通过 <em>JS</em> 操作 <em>DOM</em> 的时候，这个操作就必然涉及到了两个线程之间的通信，操作 <em>DOM</em> 次数一多，也就等同于一直在进行线程之间的通信，从而产生性能消耗。另外，操作 <em>DOM</em> 还会带来回流和重绘，这在一定程度上也有性能上的问题。</p><p>用我们传统的开发模式，原生 <em>JS</em> 或 <em>JQuery</em> 操作 <em>DOM</em> 时，浏览器会从构建 <em>DOM</em> 树开始从头到尾执行一遍流程。假设在一次操作中，我需要更新 <em>10</em> 个 <em>DOM</em> 节点，浏览器收到第一个 <em>DOM</em> 请求后并不知道还有 <em>9</em> 次更新操作，因此会马上执行流程，最终执行 <em>10</em> 次。例如，第一次计算完，紧接着下一个 <em>DOM</em> 更新请求，这个节点的坐标值就变了，前一次计算为无用功。计算 <em>DOM</em> 节点坐标值等都是白白浪费的性能。即使计算机硬件一直在迭代更新，操作 <em>DOM</em> 的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验。</p><p>在 <em>Vue、React</em> 这种框架出现后，提出了虚拟 <em>DOM</em> 的概念，虚拟 <em>DOM</em> 就是为了解决浏览器性能问题而被设计出来的。例如，如果一次操作中有 <em>10</em> 次更新 <em>DOM</em> 的动作，虚拟 <em>DOM</em> 不会立即操作 <em>DOM</em>，而是将这 <em>10</em> 次更新的 <em>diff</em> 内容保存到本地一个 <em>JS</em> 对象中，最终将这个 <em>JS</em> 对象一次性 <em>attch</em> 到 <em>DOM</em> 树上，再进行后续操作，避免大量无谓的计算量。所以，用 <em>JS</em> 对象模拟 <em>DOM</em> 节点的好处是，页面的更新可以先全部反映在 <em>JS</em> 对象（ 虚拟 <em>DOM</em> ）上，操作内存中的 <em>JS</em> 对象的速度显然要更快，等更新完成后，再将最终的 <em>JS</em> 对象映射成真实的 <em>DOM</em>，交由浏览器去绘制。</p><hr><p>-<em>EOF</em>-</p>`,114),e=[o];function t(c,r,D,y,F,i){return a(),l("div",null,e)}const A=s(p,[["render",t]]);export{m as __pageData,A as default};
