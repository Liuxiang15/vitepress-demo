import{_ as t,o as e,c as a,V as n}from"./chunks/framework.3aae2b97.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"column/6.network/07. 同源策略/课件.md","filePath":"column/6.network/07. 同源策略/课件.md","lastUpdated":1690466151000}'),o={name:"column/6.network/07. 同源策略/课件.md"},p=n('<p>浏览器有一个重要的安全策略，称之为「同源策略」</p><p>其中，$源=协议+主机+端口$，两个源相同，称之为同源，两个源不同，称之为跨源或跨域</p><p><strong>同源策略是指，若页面的源和页面运行过程中加载的源不一致时，出于安全考虑，浏览器会对跨域的资源访问进行一些限制</strong></p><p><img src="http://mdrs.yuanjin.tech/img/20210916104747.png" alt="image-20210916104747296"></p><p>同源策略对 ajax 的跨域限制的最为<em>凶狠</em>，默认情况下，它不允许 ajax 访问跨域资源</p><p><img src="http://mdrs.yuanjin.tech/img/20210916105741.png" alt="image-20210916105741041"></p><p>所以，我们通常所说的跨域问题，就是同源策略对 ajax 产生的影响</p><p>有多种方式解决跨域问题，常见的有：</p><ul><li><strong>代理</strong>，常用</li><li><strong>CORS</strong>，常用</li><li>JSONP</li></ul><p>无论使用哪一种方式，都是要让浏览器知道，我这次跨域请求的是自己人，就不要拦截了。</p>',10),r=[p];function s(_,i,c,l,m,d){return e(),a("div",null,r)}const h=t(o,[["render",s]]);export{u as __pageData,h as default};
